# pyflecs

Python bindings for the excellent [FLECS](https://www.flecs.dev/flecs/) library.

## Audience

PyFLECS is for anyone who loves FLECS, as well as for anyone who wants to build
real games with Python and an ECS oriented development approach. PyFLECS marries
the raw performance of a C based, highly optimized performance centric modern ECS
implementation, with the rapid prototyping that Python is best known for. Both
the FLECS library itself, and PyFLECS, come from a culture of indie development
where small teams are trying to make big things happen. The PyFLECS binding
attempts to help bring game engine agnostic game development to the next level
in terms of ease of rapid prototyping and iteration on game ideas.

## Philosophy

PyFLECS aims to #1 maintain close correspondence with the original C FLECS
implementation, while #2 also abstracting the underlying C concepts in a way in
which the programmer can work entirely within Python, without handling any
ctypes-wrapped structures or functions directly. #1 ensures ease of
portability as FLECS grows and evolves, light-weight abstraction so to not
impact performance, and ability to adapt easily to changes in the underlying
FLECS architecture without having to refactor class relationships too much.
#2 ensures that the code will fit comfortably inside any Python codebase,
while also emphasizing ease of use and agility that the Python programmer
looks to as a rapid prototyping language.

## Design

PyFLECS consists of two parts. Part #1 is the ctypes-based CFLECS binding, which
is automatically generated using [ctypesgen](https://github.com/ctypesgen/ctypesgen).
If so desired, this binding can be used directly, but part #2 is a Python wrapper around
the automatically generated bindings, which seeks to significantly improve the
readability and ease of use of FLECS, so it's recommended to use #2. Generating
the bindings in an automated fashion, like this, also helps with portability,
as regenerating the bindings will generate Python type errors that allow the 
programmer to track down many or most breaking changes in a relatively easy
fashion.

### CFLECS

In order to regenerate the Python bindings, you can run:

TODO: We should have a `uv` command for this

```python
.venv/bin/ctypesgen -llibflecs.dylib ./flecs.h ./flecs.c -o cflecs.py
```

Of course, this won't be that useful without first updating to the version of
FLECS to which you wish to port. The easiest way to do this is to build FLECS
from source. Following the steps in the FLECS manual in order to build with
CMake, you should be able to create a distributable in shared object form,
e.g. `libflecs.dylib`.

From there, you can either copy the header and source
files from FLECS' `distr` directory, or, alternatively, if you're building
a version of `libflecs.dylib` that includes a customized set of FLECS addons,
you can copy the appropriate files from FLECS' `src` directory to generate
the minimal set of bindings that you need for whatever your purposes are.
It should be noted that PyFLECS currently depends upon, and assumes, that
`cflecs.py` will contain the autogenerated bindings for the full version of
FLECS, including addons.

The output will be written into `cflecs.py` and references within PyFLECS will
automatically point to the updated bindings, so you can begin porting right
away.

## Examples

Before going any further, you may wish to see what PyFLECS looks like in
action. Following are some examples that showcase code written using PyFLECS
will look like.


### Performing a Query

```python
    @component
    class Position:
        x: Double                                   # x: pyflecs.Double
        y: Double                                   # y: pyflecs.Double

    world = World()

    cid = world.component(Position)                 # cid: pyflecs.IdType (c_uint64)
    entity = world.entity()                         # entity: pyflecs.IdType (c_uint64)
    world.set(entity, Position(5, 5))               # Does lazy component add

    query = world.query_kwargs(terms=[world.term_kwargs(id=Position)])

    for result in query:                            # Iterate entities with Position
        position = result.component(0, Position)    # position: Position
        print(position.x)
        print(position.y)
```


## Concepts

### Builders

PyFLECS uses builders to both ensure the underlying code does not have to deal
with much data conversion, as well as to abstract away the data conversion that
does happen to as great an extent as possible.

Builders follow these conventions:

- The builder interface will always accept Python data types, or at very least
Python data types that can be implicitly converted into their ctypes
counterparts with no extra code
- Builders may be utilized in 2 different ways,
    * chaining
    * kwargs
- Data held by a builder will always be mutable, but
- When a builder's build() method is called, the resulting built object will
consider its members read-only
- Built objects always contain ctypes types, and therefore inspecting data
contained within them will necessarily involve conversion
- When possible, inspect builder data, and avoid inspecting data inside
built objects whenever possible to avoid unnecessary conversions

#### Examples

Building a query description.
```python
query_desc = world.query_description().terms([
    ...
]).build()
```

Building a query description with kwargs.
```python
query_desc = world.query_description_kwargs(
    terms=...
)
```

Building a system description.
```python
system = world.system_description()
    .query_desc(query_desc)
    .callback(lambda x: None) # Do nothing
    .immediate(True)
    .build()
```

Building a system description with kwargs.
```python
system = world.system_description_kwargs(
    query_desc=query_desc,
    callback=lambda x: None,
    immediate=True
)
```
