# pyflecs

Python bindings for the excellent [flecs](https://www.flecs.dev/flecs/) library.

## Design

pyflecs consists of two parts; 1- `cflecs` and 2- `pyflecs`.

### cflecs

Part #1 is the auto-generated C binding which uses [ctypesgen](https://github.com/ctypesgen/ctypesgen). If so desired you can use this binding directly. For more information, see the section on [cflecs](#cflecs).

### pyflecs

pyflecs itself attempts to present a more python-like interface to to the user. See the user guide below for an introduction to the pyflecs API.

## User Guide

### Components

Components are described using decorated classes as templates, similar to python's dataclasses.

```python
from pyflecs.component import component
from pyflecs.types import Double

@component
class Position:
    x: Double
    y: Double
```

#### Limitations of python typing

Python's type are much more flexible than C types, but strict data structure sizing is part of how flecs can be efficient and performant. Therefore, it's recommended that you think of the size of your types, and use the type aliases that are provided in the `pyflecs.types` package in place of python native types.

#### Using python native types (NOT YET SUPPORTED)

In python `int` is not a sized type. Using `int` is a little more natural in python, so we consider it's OK to do so. The same applies to other types, such as `float`, or `str`. The user should be aware of the following:

- When using int, pyflecs assumes you mean CInt32
- When using float, pyflecs assumes you mean CDouble
- When using str, pyflecs assumes you mean CString (char *)

Here's an example of the same code as above, using python `float` instead.

```python
from pyflecs.component import component
from pyflecs.types import Double

@component
class Position:
    x: float
    y: float
```

### Creating components

To create your component, simply call the world method `component`.

```python
from pyflecs.component import component
from pyflecs.types import Double
from pyflecs.world import World

@component
class Position:
    x: Double
    y: Double

def main():
    world = World()
    world.component(Position)
```

The world `component` method returns an `EntityId` which represents the component inside the flecs world. When calling other methods, or interacting with flecs in a way in which you need to provide the component ID, pyflecs also allows you to use the type (`Position`, for instance) as a reference, and the flecs ID will be looked up automatically.

## Entities

### Creating an entity

```python
def main():
    world = World()
    e = world.entity()

```

Similarly to as in the component case, `world.entity()` returns an EntityId.

## Systems




## cflecs

#### Updating the autogenerated bindings

In order to regenerate cflecs, you can run:

TODO: We should have a `uv` command for this

```python
.venv/bin/ctypesgen -llibflecs.dylib ./flecs.h ./flecs.c -o cflecs.py
```

Of course, this won't be that useful without first updating to the version of flecs to which you wish to port. The easiest way to do this is to build flecs from source. Following the steps in the flecs manual in order to build with cmake, you should be able to create a distributable in shared object form, e.g. `libflecs.dylib`.

From there, you can either copy the header and source
files from flecs' `distr` directory, or, alternatively, if you're building
a version of `libflecs.dylib` that includes a customized set of flecs addons,
you can copy the appropriate files from flecs' `src` directory to generate
the minimal set of bindings that you need for whatever your purposes are.
It should be noted that pyflecs currently depends upon, and assumes, that
`cflecs.py` will contain the autogenerated bindings for the full version of
flecs, including addons.

The output will be written into `cflecs.py` and references within `pyflecs` will
automatically point to the updated bindings, so you can begin porting right
away.
